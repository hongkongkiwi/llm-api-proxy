# GitHub Copilot Instructions for anthropic-http-proxy

## Project Overview
This is an HTTP proxy server for Anthropic API requests, written in Rust. It provides a proxy layer for handling Anthropic API calls with configuration management and logging.

## Code Style and Conventions

### Rust Guidelines
- **Edition**: Rust 2021
- **Naming**: 
  - Variables and functions: `snake_case`
  - Types and structs: `PascalCase`
  - Constants: `SCREAMING_SNAKE_CASE`
- **Imports**: Group in order: std → external crates → local modules (with blank lines)
- **Error Handling**: Use `Result<T, E>` and `?` operator, avoid `unwrap()` in production
- **Async**: Use tokio runtime with `.await` syntax

### Code Organization
- Main application logic in `src/` directory
- Integration tests in `tests/` directory
- Configuration files in root directory
- Examples and installation scripts in `examples/` directory

## Key Dependencies
- `tokio`: Async runtime for I/O operations
- `hyper`: HTTP server and client implementation
- `tracing`: Structured logging and diagnostics
- `serde`: Serialization and deserialization
- `toml`: Configuration file parsing

## Development Workflow

### Building and Testing
```bash
# Build the project
cargo build
# or
just build

# Run tests
cargo test
# Test specific file
cargo test --test integration_tests
# Test specific function
cargo test <test_name>

# Lint code
cargo clippy
# or
just lint

# Format code
cargo fmt
# or
just fmt

# Run application
cargo run
# or
just run
```

### Testing Guidelines
- Write unit tests in `#[cfg(test)]` modules within source files
- Write integration tests in `tests/` directory
- Use descriptive test names that explain what is being tested
- Test both success and error cases
- Use appropriate test fixtures and mock data

## Security Best Practices
- Never commit secrets, API keys, or sensitive configuration
- Use environment variables for sensitive data (see `.env.example`)
- Validate all external input and configuration
- Follow Rust security guidelines and best practices
- Use proper error handling to avoid information leakage

## Performance Considerations
- Use async/await for all I/O operations
- Minimize allocations in performance-critical code paths
- Choose appropriate data structures based on use case
- Profile and optimize identified bottlenecks
- Use connection pooling where appropriate

## Configuration
- Use `config.toml` for application configuration
- See `config.example.toml` for configuration options
- Support environment variable overrides for sensitive settings

## When Contributing
1. Follow the existing code style and patterns
2. Add tests for new functionality
3. Update documentation as needed
4. Ensure all tests pass and code lints cleanly
5. Use appropriate error handling and logging

## Common Patterns
- Use `tracing` for structured logging with appropriate levels
- Implement proper error types with `thiserror` or similar
- Use `serde` for serialization/deserialization of config and data
- Follow async/await patterns for network operations
- Use proper lifetime annotations when needed